<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>Retro Runner — Jungle Heist</title>
<link rel="manifest" href="manifest.webmanifest">
<link rel="icon" sizes="192x192" href="icons/icon-192.png">
<meta name="theme-color" content="#0b0f15">
<style>
  html,body{height:100%} body{margin:0;background:#0b0f15;color:#e6f0ff;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center}
  .wrap{width:min(980px,96vw)}
  .card{border-radius:16px;background:rgba(255,255,255,.04);box-shadow:0 10px 30px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.06);backdrop-filter:blur(8px)}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 16px}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);font-variant-numeric:tabular-nums}
  .btn{cursor:pointer;border:none;padding:8px 12px;border-radius:10px;font-weight:800;color:#081015;background:linear-gradient(90deg,#00f5d4,#7b61ff)}
  .canvas-wrap{position:relative;aspect-ratio:16/9;width:100%}
  canvas{width:100%;height:100%;display:block;border-radius:16px;background:linear-gradient(#0f1624,#071019)}
  .scan{position:absolute;inset:0;border-radius:16px;pointer-events:none;background:repeating-linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.05) 1px, transparent 2px);mix-blend-mode:overlay;opacity:.2}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;text-align:center;max-width:86%}
  .title{font-size:26px;font-weight:900;margin-bottom:6px}
  .muted{color:#8ea0b8}
  footer{text-align:center;color:#8ea0b8;font-size:12px;padding:8px 0}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <div><b>RETRO RUNNER — Jungle Heist</b><div class="muted" style="font-size:12px">Original homage (no third‑party IP).</div></div>
      <div style="display:flex;gap:10px;align-items:center">
        <div class="pill">Score: <span id="score">0</span></div>
        <div class="pill">Lives: <span id="lives">3</span></div>
        <button id="btnRestart" class="btn">Restart</button>
      </div>
    </header>
    <div class="canvas-wrap">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="scan"></div>
      <div id="start" class="overlay">
        <div class="panel">
          <div class="title">Run. Jump. Swing. Survive.</div>
          <div class="muted">WASD/Arrow keys to move & jump. Space to grab/swing on vines. Avoid logs & scorpions. Collect treasure.</div>
          <button id="btnStart" class="btn" style="margin-top:10px">Start</button>
        </div>
      </div>
      <div id="gameover" class="overlay" style="display:none">
        <div class="panel">
          <div class="title">Game Over</div>
          <div class="muted">Press Restart to try again.</div>
        </div>
      </div>
    </div>
    <footer>© Retro Runner — an original game, inspired by classic platformers.</footer>
  </div>
</div>
<script>
(function(){
  const cv = document.getElementById('game');
  const ctx = cv.getContext('2d');
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  cv.width = 960*dpr; cv.height = 540*dpr; ctx.scale(dpr,dpr);

  const elScore = document.getElementById('score');
  const elLives = document.getElementById('lives');
  const startOverlay = document.getElementById('start');
  const gameOverOverlay = document.getElementById('gameover');
  document.getElementById('btnStart').addEventListener('click', start);
  document.getElementById('btnRestart').addEventListener('click', ()=>{reset(); start();});

  const W=960,H=540, G=1200; // world width per chunk
  const GRAV=1800, JUMP=520, SPEED=220, FRICTION=0.86;

  const state = {
    running:false, t:0, dt:0, last:0,
    camX:0, score:0, lives:3,
    hero:{x:60,y:360,w:22,h:30,vx:0,vy:0,onGround:false,grab:false,grabId:-1},
    chunks:[], // generated segments with platforms, pits, vines, items, hazards
  };

  function rng(a,b){ return Math.random()*(b-a)+a; }
  function choice(a){ return a[Math.floor(Math.random()*a.length)]; }

  function makeChunk(i){
    const x0 = i*G;
    // base ground y
    const gy = 430;
    const pits = []; // {x,w}
    const vines = []; // {x,y,len}
    const logs = []; // rolling hazards
    const scorp = []; // crawling
    const gems = []; // {x,y}
    // randomized pit/vine patterns
    for(let p=0;p<3;p++){
      const w = rng(80,180);
      const x = x0 + rng(180, G-220);
      pits.push({x,w});
      // maybe vine over pit
      if(Math.random()<0.6){
        vines.push({x:x+w/2, y:gy-180, len:160});
      }
    }
    // logs
    for(let k=0;k<2;k++){
      logs.push({x:x0+rng(200,G-100), y:gy-12, r:12, vx: choice([120,-120])});
    }
    // scorpions
    for(let s=0;s<3;s++){
      scorp.push({x:x0+rng(100,G-100), y:gy-10, w:26, h:10, vx: choice([60,-60])});
    }
    // gems
    for(let g=0;g<5;g++){
      gems.push({x:x0+rng(80,G-80), y:gy- rng(80,200)});
    }

    return {i, x0, gy, pits, vines, logs, scorp, gems};
  }

  function reset(){
    state.camX=0; state.score=0; state.lives=3;
    elScore.textContent=0; elLives.textContent=3;
    state.hero={x:60,y:360,w:22,h:30,vx:0,vy:0,onGround:false,grab:false,grabId:-1};
    state.chunks = [makeChunk(0), makeChunk(1), makeChunk(2)];
    startOverlay.style.display='';
    gameOverOverlay.style.display='none';
    state.running=false;
  }

  function start(){
    state.running=true;
    state.last=performance.now();
    startOverlay.style.display='none';
  }

  const keys=new Set();
  window.addEventListener('keydown', e=>{
    keys.add(e.key.toLowerCase());
    if((e.key===' '||e.code==='Space') && !state.hero.grab && nearVine()) {
      state.hero.grab = true; state.hero.grabId = nearVine();
      state.hero.vx = 0; state.hero.vy = 0;
    } else if(e.key.toLowerCase()==='x'){ // release
      releaseVine();
    }
  });
  window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));

  function nearVine(){
    for(const ch of state.chunks){
      for(let vi=0;vi<ch.vines.length;vi++){
        const v=ch.vines[vi]; const dx = (v.x - state.hero.x);
        if(Math.abs(dx)<18 && Math.abs((v.y - state.hero.y))<140) return vi + ch.i*100; // unique id
      }
    }
    return  -1;
  }
  function getVineById(id){
    const ci = Math.floor(id/100); const vi = id%100;
    return state.chunks.find(c=>c.i===ci)?.vines[vi];
  }
  function releaseVine(){
    if(state.hero.grab){
      // fling forward a bit
      state.hero.vx = 260;
      state.hero.vy = -80;
      state.hero.grab=false; state.hero.grabId=-1;
    }
  }

  function update(){
    const now = performance.now();
    state.dt = Math.min(0.033, (now - state.last)/1000); state.last = now;
    state.t += state.dt;
    if(!state.running) return;

    const h=state.hero; const chs = state.chunks;

    // controls
    let left = keys.has('arrowleft')||keys.has('a');
    let right= keys.has('arrowright')||keys.has('d');
    let up   = keys.has('arrowup')||keys.has('w');
    if(h.grab){
      // swing vertically
      const vine = getVineById(h.grabId);
      if(vine){
        // oscillate position around vine top with simple pendulum approx
        const len = vine.len;
        // move with left/right to swing
        if(left) h.vx -= 6;
        if(right) h.vx += 6;
        h.vx *= 0.98;
        h.x = vine.x + Math.sin(state.t*2 + h.vx*0.02)*40;
        h.y = vine.y + Math.cos(state.t*2 + h.vx*0.02)*len*0.8;
        if(up){ releaseVine(); }
      } else {
        h.grab=false;
      }
    } else {
      if(left) h.vx -= 14;
      if(right) h.vx += 14;
      if((keys.has(' ')||up) && h.onGround){ h.vy = -JUMP; h.onGround=false; }
      h.vx *= FRICTION;
      h.vy += GRAV*state.dt;
      h.x += h.vx*state.dt;
      h.y += h.vy*state.dt;
    }

    // collide with ground and pits
    h.onGround=false;
    const gy = currentGroundY(h.x);
    if(h.y + h.h/2 >= gy){
      h.y = gy - h.h/2; h.vy = 0; h.onGround = true;
    }

    // cam follow
    state.camX = Math.max(0, h.x - 200);

    // hazards: logs roll and bounce at bounds
    for(const c of chs){
      for(const log of c.logs){
        log.x += log.vx*state.dt;
        if(log.x < c.x0+40 || log.x > c.x0+G-40) log.vx *= -1;
        if(hitCircleRect(log.x, log.y, log.r, h.x, h.y, h.w, h.h)) loseLife();
      }
      for(const s of c.scorp){
        s.x += s.vx*state.dt;
        if(s.x < c.x0+30 || s.x > c.x0+G-30) s.vx *= -1;
        if(hitRectRect(s.x- s.w/2, s.y- s.h/2, s.w, s.h, h.x-h.w/2, h.y-h.h/2, h.w, h.h)) loseLife();
      }
      // gems
      for(let i=c.gems.length-1;i>=0;i--){
        const g=c.gems[i];
        if(hitCircleRect(g.x,g.y,10,h.x,h.y,h.w,h.h)){ c.gems.splice(i,1); state.score+=10; elScore.textContent=state.score; }
      }
    }

    // chunk generation ahead
    const leadChunkIndex = Math.floor((h.x+G)/G);
    if(!chs.find(c=>c.i===leadChunkIndex)){
      chs.push(makeChunk(leadChunkIndex));
      // also remove far left
      const minIndex = leadChunkIndex-2;
      for(let i=chs.length-1;i>=0;i--) if(chs[i].i<minIndex) chs.splice(i,1);
    }
  }

  function loseLife(){
    state.lives--; elLives.textContent = state.lives;
    // reset hero slightly back
    state.hero.x -= 80; state.hero.y -= 60; state.hero.vx = 0; state.hero.vy = 0; state.hero.grab=false;
    if(state.lives<=0){ state.running=false; gameOverOverlay.style.display=''; }
  }

  function currentGroundY(x){
    // find chunk and see if inside pit
    const ci = Math.floor(x/G);
    const chunk = state.chunks.find(c=>c.i===ci);
    const gy = chunk? chunk.gy : 430;
    if(!chunk) return gy;
    for(const p of chunk.pits){
      if(x>p.x && x<p.x+p.w) return H+200; // pit => fall
    }
    return gy;
  }

  function hitCircleRect(cx,cy,cr, rx,ry,rw,rh){
    const testX = Math.max(rx-rw/2, Math.min(cx, rx+rw/2));
    const testY = Math.max(ry-rh/2, Math.min(cy, ry+rh/2));
    const dx=cx-testX, dy=cy-testY;
    return dx*dx+dy*dy <= cr*cr;
  }
  function hitRectRect(x1,y1,w1,h1,x2,y2,w2,h2){
    return !(x2>x1+w1 || x2+w2 < x1 || y2>y1+h1 || y2+h2<y1);
  }

  function draw(){
    const w=960,h=540;
    ctx.clearRect(0,0,w,h);

    // parallax sky
    ctx.fillStyle = '#08121f'; ctx.fillRect(0,0,w,h);
    // grid glow
    ctx.save(); ctx.globalAlpha=0.08; ctx.strokeStyle='#7b61ff';
    for(let x= - (state.camX%40); x<w; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
    for(let y=0;y<h;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
    ctx.restore();

    // world origin relative to cam
    function worldToScreen(x,y){ return [Math.floor(x - state.camX), Math.floor(y)]; }

    // draw chunks
    for(const c of state.chunks){
      // ground
      const [gx0,gy0] = worldToScreen(c.x0, c.gy);
      ctx.fillStyle = '#214a2e'; ctx.fillRect(gx0, gy0, G, h-gy0);
      // pits
      ctx.fillStyle = '#0b0f15';
      for(const p of c.pits){
        const [px,py] = worldToScreen(p.x, c.gy);
        ctx.fillRect(px, py, p.w, h-py);
      }
      // vines
      for(const v of c.vines){
        const [vx,vy] = worldToScreen(v.x, v.y);
        ctx.strokeStyle='#00f5d4'; ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor='#00f5d4';
        ctx.beginPath(); ctx.moveTo(vx, vy); ctx.lineTo(vx, vy+v.len); ctx.stroke();
      }
      // logs
      for(const log of c.logs){
        const [lx,ly]=worldToScreen(log.x,log.y);
        ctx.save(); ctx.shadowBlur=8; ctx.shadowColor='#ffd166'; ctx.fillStyle='#b07d2a';
        ctx.beginPath(); ctx.arc(lx,ly,log.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
      // scorpions
      for(const s of c.scorp){
        const [sx,sy]=worldToScreen(s.x,s.y);
        ctx.fillStyle='#ff477e'; ctx.fillRect(sx-13,sy-5,26,10);
      }
      // gems
      for(const g of c.gems){
        const [gx,gy] = worldToScreen(g.x,g.y);
        ctx.save(); ctx.shadowBlur=12; ctx.shadowColor='#7b61ff'; ctx.fillStyle='#7b61ff';
        ctx.beginPath(); ctx.moveTo(gx,gy-8); ctx.lineTo(gx+8,gy); ctx.lineTo(gx,gy+8); ctx.lineTo(gx-8,gy); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
    }

    // hero (original character)
    const hro = state.hero;
    const [hx,hy] = worldToScreen(hro.x, hro.y);
    ctx.save();
    ctx.translate(hx,hy);
    // body
    ctx.fillStyle = '#2aa1ff'; ctx.fillRect(-hro.w/2, -hro.h/2, hro.w, hro.h);
    // cap (original red cap, no logos)
    ctx.fillStyle = '#e23a58'; ctx.fillRect(-hro.w/2, -hro.h/2-8, hro.w, 8);
    // face
    ctx.fillStyle = '#ffcf66'; ctx.fillRect(-hro.w/2+2, -hro.h/2+2, hro.w-4, hro.h/2);
    ctx.restore();

    // HUD hint
    ctx.fillStyle='#8ea0b8'; ctx.font='700 12px ui-sans-serif'; ctx.textAlign='center';
    ctx.fillText('Arrows/WASD to move & jump • Space to grab vine • X to release', w/2, h-14);
  }

  function frame(){
    update();
    draw();
    requestAnimationFrame(frame);
  }

  reset();
  frame();

  if('serviceWorker' in navigator){ window.addEventListener('load', ()=> navigator.serviceWorker.register('sw.js').catch(()=>{})); }
})();
</script>
</body>
</html>
